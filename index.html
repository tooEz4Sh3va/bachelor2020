<!DOCTYPE HTML>
<html>

<head>
    <title>Danylo Shevchuk Bachelor</title>
    <link rel="stylesheet" href="foundation-icons.css"/>
    <meta charset="utf-8">

    <style>
        /*@font-face {*/
        /*    font-family: "foundation-icons";*/
        /*    src: url("foundation-icons.eot");*/
        /*    src: url("foundation-icons.eot?#iefix") format("embedded-opentype"),*/
        /*    url("foundation-icons.woff") format("woff"),*/
        /*    url("foundation-icons.ttf") format("truetype");*/
        /*    font-weight: normal;*/
        /*    font-style: normal;*/
        /*}*/

        table td {
            padding: 5px;
            border: 1px solid black;
            width: 25px;
            height: 25px;
            text-align: center;
        }

        p.h {
            font-weight: bold;
        }

        p {
            margin: 5px;
        }

        div {
            padding: 5px;
            border: 1px solid black;
            margin: 5px;
        }

        td#empty {
            background-color: #ffffff;
        }

        td#wall {
            background-color: #aa872a;
        }

        td#start {
            background-color: #0000ff;
        }

        td#finish {
            background-color: #ee2426;
        }

        td#path {
            background-color: rgba(31, 31, 31, 0.79);
            color: #ffffff;
        }

        i {
            font-size: 18px;
        }

        select option#hidden {
            display: none;
        }
    </style>

    <!--[if lte IE 8]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

</head>

<body>

<div id='tableContainer'>
    <p class='h'> Map </p>
</div>

<div id='modSelectorContainer'>
    <p class='h'> Edit mode selector </p>
    <input type='radio' name='mod' value='empty' checked> Empty <i class="trash" style="color: #000000"></i></p>
    <input type='radio' name='mod' value='wall'> Wall <i class="align-justify" style="color: #aa872a"></i></p>
    <input type='radio' name='mod' value='start'> Start <i class="home" style="color: #0000ff"></i></p>
    <input type='radio' name='mod' value='finish'> Finish <i class="flag" style="color: #ee2426"></i></p>
</div>

<!--<div id='layerSelectorContainer'>-->
<!--    <p> Layer selector </p>-->

<!--    <select id="layerSelector">-->
<!--        <option value="0" selected>Layer #1</option>-->
<!--        <option value="1">Layer #2</option>-->
<!--        <option value="2">Layer #3</option>-->
<!--        <option value="3">Layer #4</option>-->
<!--    </select>-->
<!--    <p><input type='radio' name='layerCheck' value='1' checked> 2-dimensional mode</p>-->
<!--    <p><input type='radio' name='layerCheck' value='0'> 3-dimensional mode</p>-->
<!--</div>-->

<div id='buttonsContainer'>
    <p class='h'> Route tracing </p>

    <input type="button" id="start" value="Start"/>
    <p><input type='checkbox' name='step' value='finish'> Step-by-step mode</p>
    <input type="button" id="next" value="Next Step"/>
</div>

<script>
    const mods = ['empty', 'wall', 'start', 'finish', 'path'];
    const modsContent = [false, 'align-justify', 'home', 'flag'];
    const config = {
        mapSize: {
            x: prompt('Enter the width of the map you want to create:', '7') || 1,
            y: prompt('Enter the heights of the map you want to create:', '7') || 1,
            z: 4
        }
    };
    let twoDim = true;
    let startPosition = null;
    let finishPosition = null;
    const map = [];
    initMap();

    let modButtons = document.getElementsByName('mod');
    let currentMod = 'empty';
    initModSelector();

    // let layersSelect = document.getElementById('layerSelector');
    // let dimButtons = document.getElementsByName('layerCheck');
    // let currentZ = 0;
    // initLayerSelector();

    initStarter();

    let table;
    updateTable(map);


    function initModSelector() {
        for (let i = 0; i < modButtons.length; i++) {
            modButtons[i].onchange = selectChange;
        }

        function selectChange() {
            currentMod = this.value;
        }
    }

    function initLayerSelector() {
        layersSelect.addEventListener('change', layerChange);

        updateDimMod();

        function layerChange() {
            if (currentZ !== this.value) {
                currentZ = this.value;
                updateTable(map)
            }
        }


        for (let i = 0; i < dimButtons.length; i++) {
            dimButtons[i].onchange = dimChange;
        }

        function dimChange() {
            twoDim = this.value === '1';
            updateDimMod();
            currentZ = 0;
            updateTable(map)
        }
    }

    function updateDimMod() {
        if (twoDim) {
            Array.from(layersSelect.options).forEach(option => {
                if (option.value !== 0) {
                    option.hidden = true;
                    option.selected = false;
                } else {
                    option.selected = true;
                    layersSelect.selectedIndex = 0;
                }
            });
        } else {
            Array.from(layersSelect.options).forEach(option => {
                option.hidden = false
            })
        }
    }

    function initStarter() {
        const startButton = document.getElementById('start');

        startButton.onclick = waveStart;
    }

    function initMap() {
        for (let i = 0; i < config.mapSize.x; i++) {
            const row = [];
            for (let j = 0; j < config.mapSize.y; j++) {
                row.push({
                    mode: 0,
                    position: {
                        x: i,
                        y: j
                    }
                });
            }
            map.push(row);
        }
    }

    function updateTable(twoDimArray) {
        table = getNewTable();

        for (let i = 0; i < twoDimArray.length; i++) {
            const column = twoDimArray[i];
            const tr = document.createElement('tr');
            for (let j = 0; j < column.length; j++) {
                const cell = column[j];
                const td = document.createElement('td');
                td.id = mods[cell.mode];
                updateCell(td, cell.content ? '' : cell.waveIndex);

                if (cell.content) {
                    addIcon(td, cell);
                }

                td.addEventListener('click', function tdClick() {
                    setCell(this, cell);
                });

                tr.appendChild(td)
            }
            table.appendChild(tr)
        }
    }

    function updateCell(td, waveIndex) {
        if (waveIndex > 0) td.innerHTML = waveIndex + '';
    }

    function setCell(td, cell) {
        if (currentMod === 'start' && startPosition) {
            alert('There should be only one start, please select other block')
        } else if (currentMod === 'finish' && finishPosition) {
            alert('There should be only one finish, please select other block')
        } else {
            if (currentMod === 'start') {
                startPosition = {x: cell.position.x, y: cell.position.y};
            } else if (currentMod === 'finish') {
                finishPosition = {x: cell.position.x, y: cell.position.y};
            }
            if (td.id === 'start') {
                startPosition = null;
            } else if (td.id === 'finish') {
                finishPosition = null;
            }
            td.id = currentMod;

            updateCell(td, cell.waveIndex);
            const index = mods.indexOf(currentMod);
            cell.mode = index;
            cell.content = modsContent[index] || null;

            const icon = td.querySelectorAll('i');
            if (icon[0]) {
                icon[0].remove();
            }
            addIcon(td, cell);

        }
    }

    function addIcon(td, cell) {
        const icon = document.createElement('i',);
        icon.className = cell.content;
        td.appendChild(icon);
    }

    function clearTable() {
        table = document.getElementById('table');
        if (table) {
            table.remove();
            // parent.delete(table);
        }
    }

    function getNewTable() {
        const parent = document.getElementById('tableContainer');

        clearTable(parent);
        let table = document.createElement('table');
        table.id = 'table';

        parent.appendChild(table);
        return table;
    }

    // wave algo section! BEWARE!!!

    let elementsQueue = [];
    let nextElements = [];
    let currentWaveIndex = 0;
    let currentBackIndex = 0;
    let finishFound = false;

    function waveStep(position) {
        const x = position.x;
        const y = position.y;

        if (map[x + 1] && map[x + 1][y] && !map[x + 1][y].waveIndex) {
            if (map[x + 1][y].mode === 0) {
                map [x + 1][y].waveIndex = currentWaveIndex + 1;
                nextElements.push({x: x + 1, y: y})
            } else if (map[x + 1][y].mode === 3) {
                finishFound = true;
                map [x + 1][y].waveIndex = currentWaveIndex + 1;
            }
        }

        if (map[x - 1] && map[x - 1][y] && !map[x - 1][y].waveIndex) {
            if (map[x - 1][y].mode === 0) {
                map [x - 1][y].waveIndex = currentWaveIndex + 1;
                nextElements.push({x: x - 1, y: y})
            } else if (map[x - 1][y].mode === 3) {
                finishFound = true;
                map [x - 1][y].waveIndex = currentWaveIndex + 1;
            }
        }

        if (map[x] && map[x][y + 1] && !map[x][y + 1].waveIndex) {
            if (map[x][y + 1].mode === 0) {
                map [x][y + 1].waveIndex = currentWaveIndex + 1;
                nextElements.push({x: x, y: y + 1})
            } else if (map[x][y + 1].mode === 3) {
                finishFound = true;
                map [x][y + 1].waveIndex = currentWaveIndex + 1;
            }
        }

        if (map[x] && map[x][y - 1] && !map[x][y - 1].waveIndex) {
            if (map[x][y - 1].mode === 0) {
                map [x][y - 1].waveIndex = currentWaveIndex + 1;
                nextElements.push({x: x, y: y - 1})
            } else if (map[x][y - 1].mode === 3) {
                finishFound = true;
                map [x][y - 1].waveIndex = currentWaveIndex + 1;
            }
        }

    }

    function waveStart() {
        if (!startPosition) {
            alert('Please mark starting position before running');
        } else {
            if (!finishPosition) {
                alert('Please mark finish position before running');
            } else {
                waveStep(startPosition);
                currentWaveIndex++;
                while (nextElements[0]) {
                    elementsQueue = nextElements;
                    nextElements = [];

                    while (elementsQueue[0]) {
                        waveStep(elementsQueue[0]);
                        elementsQueue.splice(0, 1);
                        if (finishFound) break;
                    }
                    currentWaveIndex++;
                    updateTable(map);
                    console.log('step ended');
                    if (finishFound) {
                        currentBackIndex = currentWaveIndex;
                        currentWaveIndex = 0;
                        break
                    }
                }
                console.log('wave ended');
                if (finishFound) {
                    findWayHome();
                } else {
                    alert('Sadly to say, but I do not know da wae');
                }
            }
        }
    }

    function comeBackStep(position) {
        // выбрать среди соседних ячейку, помеченную числом на 1 меньше числа в текущей ячейке
        // перейти в выбранную ячейку и добавить её к пути

        const x = position.x;
        const y = position.y;

        if (map[x + 1] && map[x + 1][y] && map[x + 1][y].waveIndex && map [x + 1][y].waveIndex + 1 === currentBackIndex) {
            map[x + 1][y].mode = 4;
            map[x + 1][y].content = 'step arrow-up';
            return map[x + 1][y];
        } else if (map[x - 1] && map[x - 1][y] && map[x - 1][y].waveIndex && map [x - 1][y].waveIndex + 1 === currentBackIndex) {
            map[x - 1][y].mode = 4;
            map[x - 1][y].content = 'step arrow-down';
            return map[x - 1][y];
        } else if (map[x] && map[x][y + 1] && map[x][y + 1].waveIndex && map [x][y + 1].waveIndex + 1 === currentBackIndex) {
            map[x][y + 1].mode = 4;
            map[x][y + 1].content = 'step arrow-left';
            return map[x][y + 1];
        } else if (map[x] && map[x][y - 1] && map[x][y - 1].waveIndex && map [x][y - 1].waveIndex + 1 === currentBackIndex) {
            map[x][y - 1].mode = 4;
            map[x][y - 1].content = 'step arrow-right';
            return map[x][y - 1];
        }
    }

    function findWayHome() {
        if (startPosition && finishPosition) {
            let currentCell = map[finishPosition.x][finishPosition.y];
            while (currentCell && currentCell.mode !== 2) {
                currentCell = comeBackStep(currentCell.position);
                console.log('step back found');
                updateTable(map);
                currentBackIndex--;
            }
            console.log('way home found');
        }
    }

    console.log(map);

</script>


</body>

</html>